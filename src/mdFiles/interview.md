## 1.浏览器

### 1.1 浏览器缓存

```shell
浏览器缓存分为强缓存和协商缓存
http第一次请求资源，服务返回资源的时候在响应头中设置跟缓存相关的属性
其中跟强缓存有关的属性
Pragma(http/1.0)：no-cache 不直接使用缓存，根据新鲜度使用缓存 优先级高
Cache-Control(http/1.1)：优先级中
+ no-cache 不直接使用缓存，根据新鲜度使用缓存
+ no-store  不使用缓存，每次都请求下载新的资源
+ max-age: 缓存时长
+ public/privite 是否只能被单个用户使用
+ must-revalidate 每次访问都需要缓存校验
Expires(http/1.0+) 优先级低   过期时间
跟协商缓存相关的属性
Etag：hash值，资源每次被修改后都会修改这个值，优先级高
Last-modified: GMT时间值

当再次请求资源时首先判断Cache-control 的值，如果是max-age 没有过期，或者expirse的值没有过期，直接取缓存不需要跟服务器进行交互
如果资源已经过期或者cache-control的值为no-cache,就进入协商缓存阶段
协商缓存时浏览器重新向服务器端请求数据，并在请求头中添加IF-none-match, If-Modified-Since,属性，其中If-none-match 时Etag的值，if-modified-since 时last-modified 的值，服务器接收到请求后判断请求头中的属性的值是否与之前的相等，如果相等就返回状态码304，告诉浏览器资源位修改直接使用缓存，如果不相等就返回状态码200，同时返回更新后的数据，并进行重新缓存

强缓存的缺点：在资源未过期之前无法获得更新后的资源，可以Ctrl+f5 强制刷新
```

### 1.2 浏览器渲染

浏览器是多线程的，js是单线程的

```shell
浏览器接收到服务器返回的html源代码后， 在内存中开辟一块占内存，为其提供一个执行环境；同时分配一个主线程去一行行的解析和执行代码（频繁的进栈出栈）。 当浏览器遇到link/script/img等请求时，都会开辟一个新的线程去加载资源文件，同时开启一个Task QUEUE 任务队列，并将请求任务放入。第一次自上而下走完之后，只生成DOM Tree。 然后通过Event Loop 机制到Task Queue 中获取返回的CSS，生成CSSOM。 然后通过DOM Tree 和CSSDM 生成Render Tree  渲染树
回流：根据生成的RenderTree ，计算节点在设备视口中的确切的位置和大小。
重绘： 更具渲染树和回流得到的几何信息，得到节点的绝对像素
Display; 将像素发送个GPU， 展示在页面上
```



## 2.http

### 2.1 http2.0相关

```shell
http1.1存在的问题
+ 线头阻塞，一个TCP链接只能发送一个请求，前面的请求未完成后面的请求就会一直排队等待
+ 多个TCP链接，虽然http1.1管线化可以支持请求并发，但是浏览器很难实现，Chrome，firefox都禁止了管线化。多个TCP链接成本高，还会存在慢启动问题
+ 头部冗余，采用文本格式，首部未压缩，每一个请求都会携带cookie，user-agent等相同头部
+ 客户端需要主动请求

http2.0 特性
+ 二进制分层，http2是二进制协议，传输二进制数据。将返回数据分为两个帧，头部帧和数据帧
+ 多路复用 多个请求在一个TCP链接上完成，真正的实现并发请求。具体过程是，TCP链接上可以有任意多个流，数据在返回时分割成一个或者多个帧，帧在流里面传输，帧传输到达后进行重组，形成完整的请求响应。

头部压缩： 头部压缩需要在浏览器和服务器之间
+ 维护一份相同的静态字典，包含常见的头部名称，以及常见头部名称和值得组合
+ 维护一份相同的动态字典，可以动态的添加内容
+ 通过静态Huffman编码对传输的首部字段进行编码
请求时，请求头中的静态属性会在静态字典中查找，传输时只穿索引值。动态属性第一次请求时传输数据，并将属性名和值写入动态字典，第二次请求时就查找动态字典传输索引值

服务器端推送
```

### 2.2 TCP三次握手四次挥手

#### 2.2.1 三次握手

```shell
相关字段语义：
Seq序号，占32位，用来标记TCP源端口到目的端口的数据;
Ack序号，确认序号，占32位，只有ACK标志位为1时，才有效，确认号=发送发Seq+1;
标志位：只有0和1两种状态
+ SYN：值为1是表示发起一个新的链接
+ ACK：值为1时表示确认收到请求链接，确认收到的序号有效
+ PSH：接收方应该尽快将这个报文交给应用层
+ RST：重置链接
+ FIN：释放链接

三次握手：
+第一次握手，客户端向服务端发起连接请求，首先客户端随机生成一个随机序列号（假如100），然后在像服务端发送的报文中将Seq序列号设置100， SYN标志位设置为1，表示建立新链接
+第二次握手，服务端收到客户端发过来的报文后，发现SYN=1，知道是一个请求链接，于是将客户端的序列号存起来，并随机生成自己的一个序列号（1000）。 然后给客户端回复一段报文，其中报文的标志位SYN=1，ACK=1，序列号seq=1000，确认号Ack=收到的序列号+1（100+1）
+第三次握手，客户端收到报文发现ACK=1，确认号ack=101,知道服务端已经收到了序列号为100的那段报文，同时发现SYN=1，知道了服务器同意本次链接，于是将服务器的序列号1000存了起来，然后像服务端再回复一段报文，ACK=1，seq=101,ack=1000+1. 服务端收到报文后发现ACK=1，ack=1000+1，就知道客户端收到了序列号为1000的报文，这样客户端和服务端就建立了TCP链接
```

![三次握手.png](https://user-gold-cdn.xitu.io/2020/1/7/16f7e03b1ea507e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





#### 2.2.2四次挥手

```shell
比如客户端初始化的序列号seq=100，服务端初始化的序列号seq=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。

+ 第一次挥手，客户端的数据发送完之后，像服务端发送释放连接的报文，FIN标志位设置为1，seq设置为100+1+1000（1是请求连接是占用的一个序列号， 发送的FIN报文也占用一个序列号，发送FIN报文后只是不能发送数据，仍然可以接收数据）
+ 第二次挥手，服务端收到客户端发送的释放连接报文后回复确认报文，确认报文包含ACK=1，确认号ack=100+1+1000+1，序列号seq=300+2000，此时服务端处于等待关闭的状态，并不马上发送FIN报文，因为服务端可能还有数据没有发送完
+ 第三次挥手，当服务端的数据发送完之后比如50个字节，就回发送释放连接的报文，FIN=1， 序列号seq=300+2000+50,(ACK 和 ack 在这个报文中是否有需要再查资料，因为看的资料中有的有，有的没有)
+ 第四次挥手，客户端收到服务端的FIN报文后，想服务端发送确认报文，ACK=1， ack=300+2000+50+1,序列号1102. 注意，客户端发送确认报文后并不是马上释放TCP链接，而是经过2MSL（最长报文寿命的2倍）后释放TCP连接。服务端收到确认报文后，马上释放连接，所以服务端结束TCP连接时间要比客户端早
```

![img](https://user-gold-cdn.xitu.io/2020/1/7/16f7e03b21a07f0c?imageslim)

#### 2.2.3 为什么TCP连接的时候是3次，两次不可以吗？

```shell
因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。
如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。

```

#### 2.2.4 为什么TCP关闭的时候是4次？

```shell
因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)
```

#### 2.2.5 为什么客户端发出第四次挥手后要等2MSL的时间才释放连接？

```shell
这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。
```

#### 2.2.6 如果已经建立连接，客户端出现故障怎么办？

```shell
TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
```

### 2.3  Cookie和Session 的区别

```shell
Cookie 和 Session 都是保存用户的状态信息。但是Cookie是保存在客户端，Session 是保存在服务器
浏览器第一次请求时，服务端会在响应报文头部的set-cookie属性中放入cookie值，浏览器收到后会读取cookie值并保存在本地，再次发送信息的时候会在请求头中携带上cookie信息

session保存在服务器中，当再次接受到请求时，只需要从session中查找客户的状态就行。 但是会增加服务器的压力，所以要设置session的有效期，缓解服务器压力

```

### 2.4 断点续传和多线程下载

```shell
断点续传： 在网络不好的情况下，链接断开以后，后续只需要获取剩下未传的部分就行
多线程下载：就是在下载大型文件的时候，开启多个线程，每个线程下载文件的一部分，下载完成后再拼接成一个完整的文件
他们实现的核心理论基础就是http的范围请求
http响应头部有Access-Ranges属性标记是否支持范围请求，只有一个可选参数bytes
通过在请求头中添加Range请求头，指定请求的内容的字节范围
在响应头中通过Content-Range返回内容实体的字节范围，Content-length 表示返回的范围长度
在请求中，通过If-Range 来区分文件是否变动，如果资源有改动，就重新下载

范围请求返回的状态吗是206
```

### 2.5 WebSocket

### 2.6 HTTPS

### 3. 性能优化

```shell
1. http方面，减少请求次数，和大小
   + 资源合并和压缩
   + 图片懒加载
   + 音视频走流文件
2. 尽可能减少或者避免重绘和回流
   + 尽量减少操作DOM
   + 分离读写，当代浏览器都有渲染队列的机制，多次连续更改DOM属性，只会引发一次回流
     其中读属性操作会刷新渲染对列，导致马上回流重绘，所以要尽量分开(offsetTop/Left/Width/Height,          clientTop/Left/Width/Height,scrollTop/Left/Width/Height, getComputedStyle,CurrentStyle 等)
    + 批量处理DOM CSS 属性
    + 缓存处理
    + 元素批量处理，文档碎片createDocumentFragment，模板字符串拼接
    + 动画效果应用到position：absolute或者fixed的属性上，脱离文档流，引发的回流不会影响其他的节点
    + CSS3 硬件加速（GPU）加速。 transform/opcity/filters,会规避回流和重绘，开启硬件加速。但是可能会占用大量内存，性能消耗严重，可能导致字体模糊
    + 避免table布局和CSS使用javascript表达式
```



## 最后

```shell
DNS解析
HTTP状态码，HTTP报文
```

