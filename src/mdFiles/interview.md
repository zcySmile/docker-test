## 1.浏览器

### 1.1 浏览器缓存

```shell
浏览器缓存分为强缓存和协商缓存
http第一次请求资源，服务返回资源的时候在响应头中设置跟缓存相关的属性
其中跟强缓存有关的属性
Pragma(http/1.0)：no-cache 不直接使用缓存，根据新鲜度使用缓存 优先级高
Cache-Control(http/1.1)：优先级中
+ no-cache 不直接使用缓存，根据新鲜度使用缓存
+ no-store  不使用缓存，每次都请求下载新的资源
+ max-age: 缓存时长
+ public/privite 是否只能被单个用户使用
+ must-revalidate 每次访问都需要缓存校验
Expires(http/1.0+) 优先级低   过期时间
跟协商缓存相关的属性
Etag：hash值，资源每次被修改后都会修改这个值，优先级高
Last-modified: GMT时间值

当再次请求资源时首先判断Cache-control 的值，如果是max-age 没有过期，或者expirse的值没有过期，直接取缓存不需要跟服务器进行交互
如果资源已经过期或者cache-control的值为no-cache,就进入协商缓存阶段
协商缓存时浏览器重新向服务器端请求数据，并在请求头中添加IF-none-match, If-Modified-Since,属性，其中If-none-match 时Etag的值，if-modified-since 时last-modified 的值，服务器接收到请求后判断请求头中的属性的值是否与之前的相等，如果相等就返回状态码304，告诉浏览器资源位修改直接使用缓存，如果不相等就返回状态码200，同时返回更新后的数据，并进行重新缓存

强缓存的缺点：在资源未过期之前无法获得更新后的资源，可以Ctrl+f5 强制刷新
```

### 1.2 浏览器渲染

浏览器是多线程的，js是单线程的

```shell
浏览器接收到服务器返回的html源代码后， 在内存中开辟一块占内存，为其提供一个执行环境；同时分配一个主线程去一行行的解析和执行代码（频繁的进栈出栈）。 当浏览器遇到link/script/img等请求时，都会开辟一个新的线程去加载资源文件，同时开启一个Task QUEUE 任务队列，并将请求任务放入。第一次自上而下走完之后，只生成DOM Tree。 然后通过Event Loop 机制到Task Queue 中获取返回的CSS，生成CSSOM。 然后通过DOM Tree 和CSSDM 生成Render Tree  渲染树
回流：根据生成的RenderTree ，计算节点在设备视口中的确切的位置和大小。
重绘： 更具渲染树和回流得到的几何信息，得到节点的绝对像素
Display; 将像素发送个GPU， 展示在页面上
```



## 2.http

### 2.1 HTTP1 、HTTP2 、HTTP3 的演变

#### 2.1.1 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？

```shell
1. 使用TCP长连接的方式改变了HTTP1.0 短连接造成的性能消耗
2. 支持管道网络传输，减少整体相应时间
```

#### 2.1.2  对于HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？

```shell
http1.1存在的问题
+ 队头阻塞，服务器只能按照请求的顺序依次处理，前面的请求未完成后面的请求就会一直排队等待
+ 头部冗余，采用文本格式，首部未压缩，只能压缩body部分，每一个请求都会携带cookie，user-agent等相同头部，造成资源浪费
+ 请求只能从客户端发起，服务器只能被动相应
+ 没有请求优先级控制

http2.0 特性
+ 基于https, 安全性高
+ 二进制分帧，http2是二进制协议，传输二进制数据。将返回数据分为两个帧，头部帧和数据帧
+ 多路复用 多个请求在一个TCP链接上完成，真正的实现并发请求。具体过程是，TCP链接上可以有任意多个流，数据在返回时分割成一个或者多个帧，帧在流里面传输，帧传输到达后进行重组，形成完整的请求响应。

头部压缩： 头部压缩需要在浏览器和服务器之间
+ 维护一份相同的静态字典，包含常见的头部名称，以及常见头部名称和值得组合
+ 维护一份相同的动态字典，可以动态的添加内容
+ 通过静态Huffman编码对传输的首部字段进行编码
请求时，请求头中的静态属性会在静态字典中查找，传输时只穿索引值。动态属性第一次请求时传输数据，并将属性名和值写入动态字典，第二次请求时就查找动态字典传输索引值

服务器端推送
```

### 2.2 TCP三次握手四次挥手

#### 2.2.1 三次握手

```shell
相关字段语义：
Seq序号，占32位，用来标记TCP源端口到目的端口的数据;
Ack序号，确认序号，占32位，只有ACK标志位为1时，才有效，确认号=发送发Seq+1;
标志位：只有0和1两种状态
+ SYN：值为1是表示发起一个新的链接
+ ACK：值为1时表示确认收到请求链接，确认收到的序号有效
+ PSH：接收方应该尽快将这个报文交给应用层
+ RST：重置链接
+ FIN：释放链接

三次握手：
+第一次握手，客户端向服务端发起连接请求，首先客户端随机生成一个随机序列号（假如100），然后在像服务端发送的报文中将Seq序列号设置100， SYN标志位设置为1，表示建立新链接
+第二次握手，服务端收到客户端发过来的报文后，发现SYN=1，知道是一个请求链接，于是将客户端的序列号存起来，并随机生成自己的一个序列号（1000）。 然后给客户端回复一段报文，其中报文的标志位SYN=1，ACK=1，序列号seq=1000，确认号Ack=收到的序列号+1（100+1）
+第三次握手，客户端收到报文发现ACK=1，确认号ack=101,知道服务端已经收到了序列号为100的那段报文，同时发现SYN=1，知道了服务器同意本次链接，于是将服务器的序列号1000存了起来，然后像服务端再回复一段报文，ACK=1，seq=101,ack=1000+1. 服务端收到报文后发现ACK=1，ack=1000+1，就知道客户端收到了序列号为1000的报文，这样客户端和服务端就建立了TCP链接
```

![三次握手.png](https://user-gold-cdn.xitu.io/2020/1/7/16f7e03b1ea507e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





#### 2.2.2四次挥手

```shell
比如客户端初始化的序列号seq=100，服务端初始化的序列号seq=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。

+ 第一次挥手，客户端的数据发送完之后，像服务端发送释放连接的报文，FIN标志位设置为1，seq设置为100+1+1000（1是请求连接是占用的一个序列号， 发送的FIN报文也占用一个序列号，发送FIN报文后只是不能发送数据，仍然可以接收数据）
+ 第二次挥手，服务端收到客户端发送的释放连接报文后回复确认报文，确认报文包含ACK=1，确认号ack=100+1+1000+1，序列号seq=300+2000，此时服务端处于等待关闭的状态，并不马上发送FIN报文，因为服务端可能还有数据没有发送完
+ 第三次挥手，当服务端的数据发送完之后比如50个字节，就回发送释放连接的报文，FIN=1， 序列号seq=300+2000+50,(ACK 和 ack 在这个报文中是否有需要再查资料，因为看的资料中有的有，有的没有)
+ 第四次挥手，客户端收到服务端的FIN报文后，想服务端发送确认报文，ACK=1， ack=300+2000+50+1,序列号1102. 注意，客户端发送确认报文后并不是马上释放TCP链接，而是经过2MSL（最长报文寿命的2倍）后释放TCP连接。服务端收到确认报文后，马上释放连接，所以服务端结束TCP连接时间要比客户端早
```

![img](https://user-gold-cdn.xitu.io/2020/1/7/16f7e03b21a07f0c?imageslim)

#### 2.2.3 为什么TCP连接的时候是3次，两次不可以吗？

```shell
因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。
如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。

```

#### 2.2.4 为什么TCP关闭的时候是4次？

```shell
因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)
```

#### 2.2.5 为什么客户端发出第四次挥手后要等2MSL的时间才释放连接？

```shell
这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。
```

#### 2.2.6 如果已经建立连接，客户端出现故障怎么办？

```shell
TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
```

### 2.3  Cookie和Session 的区别

```shell
Cookie 和 Session 都是保存用户的状态信息。但是Cookie是保存在客户端，Session 是保存在服务器
浏览器第一次请求时，服务端会在响应报文头部的set-cookie属性中放入cookie值，浏览器收到后会读取cookie值并保存在本地，再次发送信息的时候会在请求头中携带上cookie信息

session保存在服务器中，当再次接受到请求时，只需要从session中查找客户的状态就行。 但是会增加服务器的压力，所以要设置session的有效期，缓解服务器压力

```

### 2.4 断点续传和多线程下载

```shell
断点续传： 在网络不好的情况下，链接断开以后，后续只需要获取剩下未传的部分就行
多线程下载：就是在下载大型文件的时候，开启多个线程，每个线程下载文件的一部分，下载完成后再拼接成一个完整的文件
他们实现的核心理论基础就是http的范围请求
http响应头部有Access-Ranges属性标记是否支持范围请求，只有一个可选参数bytes
通过在请求头中添加Range请求头，指定请求的内容的字节范围
在响应头中通过Content-Range返回内容实体的字节范围，Content-length 表示返回的范围长度
在请求中，通过If-Range 来区分文件是否变动，如果资源有改动，就重新下载

范围请求返回的状态吗是206
```

### 2.5 WebSocket

```shell
WebSocket是HTML5的协议，实现服务器和浏览器之间的全双工通信，一开始的握手还是靠借助http请求完成
```



### 2.6 HTTPS

```shel
http和https的区别：
+ http明文传输， https通过SSL\TLs 进行加密
+ 端口号不同，80 和 443
+ https需要到CA申请证书，一般都是收费的
+ http建立连接比较简单，TCP进行三次握手之后就可以进行传输，Https还要进行SSL\TLs握手，然后再进行加密传输

为什么使用https
+ 建立一个安全的信息通道，保证数据传输的安全性
+ 确认网站的真实性，防止钓鱼网站

对称加密： 就是加密和解密使用的是同一个密钥。 问题是怎么保证密钥在传输过程中的安全性，也就是没被窃取？

非对称加密（RSA）：公钥加密信息，私钥解密信息。但是非对称加密很慢，而且是慢很多

非对称密钥+对称密钥： 非对称加密算法传输对称加密的密钥，然后通过对称加密传输信息

中间人攻击： 在使用非对称加密算法传输对称密钥的时候，中间人也可以拦截非对称加密的公钥，然后对公钥进行篡改。

数字证书：网站信息+公钥+hash算法 ---> 消息摘要--->用CA私钥加密---->数字签名,   数字签名+网站信息+公钥 就是数字证书

hash算法也可以替换成其他的，只要客户端和服务端保持一致


客户端如何判断服务端公钥的正确性？ 
客户端拿到数字证书， 将其中的网站信息和公钥通过相同的hash算法进行计算得到一个消息摘要， 然后再将数字签名通过CA的公钥解密得到一个消息摘要， 将两个消息摘要相比较，如果一样就是拿到的正确的服务端的公钥

在获取服务端公钥的过程中，客户端和服务端会协商生成会话密钥，然后通过会话密钥加密数据进行通信

https 整个的通信流程是：
TCP三次握手-->SSL\TLS握手-->数据加密传输-->四次挥手断开连接
```

```shell
SSL\TLS 协议基本流程
1. 客户端向服务端索要并验证服务器的公钥
2. 双方协商产生【会话密钥】
3. 双方通过会话密钥加密信息进行传送

前两步就是SSL\TLS建立的过程，也是握手阶段，共有四次通信
1. TCP三次握手之后， 客户端向服务端发送支持的SSL\TLS的版本，客户端产生的随机数，客户端支持的密码套件列表
2. 服务端接收到客户端的信息后，向客户端返回确认使用的SSL\TLS版本（如果客户端不支持，就关闭加密通信），服务端的一个随机数，确认使用的密码套件列表，服务器的数字证书
3. 客户端收到服务端的回复之后，会通过其内置的CA公钥验证服务端数字证书的有效性。 如果证书有效，就会从证书中取出服务器的公钥，并通过服务器的公钥加密一个随机数，然后将加密的随机数，加密算法更改通知，客户端结束握手通知发送给服务端
4. 服务端收到加密的随机数后，想客户端返回更改加密通信算法通知，服务器结束握手通知

通过四次通信，服务器和客户端都会有三个随机数， 然后各自通过协商的加密算法生成本次通信的会话密钥
```



### 2.7 http状态码

```shell
1XX 提示信息，表示协议处理的中间状态
2XX 请求成功返回
    200 响应头中有body数据
    204 相应头中没有body数据
    206 相应返回的不是完整的数据，只是一部分
3XX 表示资源重定向
    300 请求的资源有多个返回结果
    301 永久重定向，返回新的URL
    302 临时重定向，资源还在，但是暂时需要另外一个url访问
    301和302都会在相应头的Location字段中返回新的url,然后浏览器会自动跳转
    304 请求的资源未更改，可以使用缓存
 4XX 表示客户端错误
     400 请求有语法错误，浏览器无法解析
     401 服务端无法识别客户端的身份，拒绝资源访问
     403 服务器可以识别客户端的身份，但是客户端没有访问请求资源的权限
     404 资源不存在
     405 请求方法不能用
  5XX 服务端错误
      500 服务器内部错误，遇到一个无法处理的错误，但是不知道具体是什么
      501 请求方法服务器不支持，无法处理
      502 网关不可用。 服务器作为网关或者代理时出现的错误，表示服务器自身工作正常，但是访问其他服务时出现了错误
      503 服务不可用。 通常是服务器正在维护或者超载
      504 网关超时。 服务器作为网关工作时，未能及时得到响应
      505 http版本不被服务器支持
```

### 2.8 http常用字段

```shell
请求字段：
Host: 服务器域名
Connection：Keep-Alive 要求服务器保持TCP持久连接，可以是其他请求复用
Accept： 浏览器接收的数据格式
Accept-Encoding: 接收的数据压缩方式
```

### 2.9 GET 和 POST 都是安全和幂等的吗？

```shell
安全： 请求方法不会破坏服务器上的资源
幂等： 多次执行相同的操作，得到的结果是相同的

GET 是只读操作，每次获取的资源都是安全和幂等的
POST 会提交数据，修改服务器的资源，是不安全的，而且多次提交就会创建多个资源，也不是幂等的
```

### 2.10 http中的管道技术

```shell
在一个TCP连接中，可以发出多个请求，而且不用等第一个请求返回就可以发送第二个请求，也就是并行发起多个请求， 但是再服务端仍然是按照请求的顺序进行返回处理的，如果前面的请求响应很慢，后面的还是会排队等着，照成队头阻塞
```



### 3. 性能优化

```shell
1. http方面，减少请求次数，和大小
   + 资源合并和压缩
   + 图片懒加载
   + 音视频走流文件
2. 尽可能减少或者避免重绘和回流
   + 尽量减少操作DOM
   + 分离读写，当代浏览器都有渲染队列的机制，多次连续更改DOM属性，只会引发一次回流
     其中读属性操作会刷新渲染对列，导致马上回流重绘，所以要尽量分开(offsetTop/Left/Width/Height,          clientTop/Left/Width/Height,scrollTop/Left/Width/Height, getComputedStyle,CurrentStyle 等)
    + 批量处理DOM CSS 属性
    + 缓存处理
    + 元素批量处理，文档碎片createDocumentFragment，模板字符串拼接
    + 动画效果应用到position：absolute或者fixed的属性上，脱离文档流，引发的回流不会影响其他的节点
    + CSS3 硬件加速（GPU）加速。 transform/opcity/filters,会规避回流和重绘，开启硬件加速。但是可能会占用大量内存，性能消耗严重，可能导致字体模糊
    + 避免table布局和CSS使用javascript表达式
```



## 最后

```shell
DNS解析
HTTP状态码，HTTP报文
```

