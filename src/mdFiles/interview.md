## 1.浏览器

### 1.1 浏览器缓存

```shell
浏览器缓存分为强缓存和协商缓存
http第一次请求资源，服务返回资源的时候在响应头中设置跟缓存相关的属性
其中跟强缓存有关的属性
Pragma(http/1.0)：no-cache 不直接使用缓存，根据新鲜度使用缓存 优先级高
Cache-Control(http/1.1)：优先级中
+ no-cache 不直接使用缓存，根据新鲜度使用缓存
+ no-store  不使用缓存，每次都请求下载新的资源
+ max-age: 缓存时长
+ public/privite 是否只能被单个用户使用
+ must-revalidate 每次访问都需要缓存校验
Expires(http/1.0+) 优先级低   过期时间
跟协商缓存相关的属性
Etag：hash值，资源每次被修改后都会修改这个值，优先级高
Last-modified: GMT时间值

当再次请求资源时首先判断Cache-control 的值，如果是max-age 没有过期，或者expirse的值没有过期，直接取缓存不需要跟服务器进行交互
如果资源已经过期或者cache-control的值为no-cache,就进入协商缓存阶段
协商缓存时浏览器重新向服务器端请求数据，并在请求头中添加IF-none-match, If-Modified-Since,属性，其中If-none-match 时Etag的值，if-modified-since 时last-modified 的值，服务器接收到请求后判断请求头中的属性的值是否与之前的相等，如果相等就返回状态码304，告诉浏览器资源位修改直接使用缓存，如果不相等就返回状态码200，同时返回更新后的数据，并进行重新缓存

强缓存的缺点：在资源未过期之前无法获得更新后的资源，可以Ctrl+f5 强制刷新
```

## 2.http

### 2.1 http2.0相关

```shell
http1.1存在的问题
+ 线头阻塞，一个TCP链接只能发送一个请求，前面的请求未完成后面的请求就会一直排队等待
+ 多个TCP链接，虽然http1.1管线化可以支持请求并发，但是浏览器很难实现，Chrome，firefox都禁止了管线化。多个TCP链接成本高，还会存在慢启动问题
+ 头部冗余，采用文本格式，首部未压缩，每一个请求都会携带cookie，user-agent等相同头部
+ 客户端需要主动请求

http2.0 特性
+ 二进制分层，http2是二进制协议，传输二进制数据。将返回数据分为两个帧，头部帧和数据帧
+ 多路复用 多个请求在一个TCP链接上完成，真正的实现并发请求。具体过程是，TCP链接上可以有任意多个流，数据在返回时分割成一个或者多个帧，帧在流里面传输，帧传输到达后进行重组，形成完整的请求响应。

头部压缩： 头部压缩需要在浏览器和服务器之间
+ 维护一份相同的静态字典，包含常见的头部名称，以及常见头部名称和值得组合
+ 维护一份相同的动态字典，可以动态的添加内容
+ 通过静态Huffman编码对传输的首部字段进行编码
请求时，请求头中的静态属性会在静态字典中查找，传输时只穿索引值。动态属性第一次请求时传输数据，并将属性名和值写入动态字典，第二次请求时就查找动态字典传输索引值

服务器端推送
```



